<!DOCTYPE html>
<html>
  <head>
    <title>I.B.U Dashboard</title>
    <link
      rel="icon"
      type="image/svg+xml"
      href="{{ url_for('static', filename='ibu-icon.svg') }}"
    />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- Preload critical images to avoid late layout shifts -->
    <link
      rel="preload"
      as="image"
      href="{{ url_for('static', filename='ibu-icon.svg') }}"
    />
    <link
      rel="preload"
      as="image"
      href="{{ url_for('static', filename='ibu-text.svg') }}"
    />
    <link
      rel="stylesheet"
      type="text/css"
      href="{{ url_for('static', filename='index.css') }}?v={{ range(1000, 9999) | random }}"
    />
    <style>
      /* Ensure hidden state beats global !important display */
      .stats-panel.is-hidden {
        display: none !important;
      }
      /* Draggable stats panel affordances */
      #stats-panel {
        position: fixed;
        z-index: 999;
        width: 320px;
        display: none; /* default hidden until JS decides */
        cursor: grab; /* hand-like cursor */
      }
      #stats-panel.visible {
        display: block;
      }
      #stats-panel.dragging {
        cursor: grabbing;
      }
      #stats-panel .drag-hint {
        position: absolute;
        top: 6px;
        right: 36px;
        font-size: 0.8rem;
        color: rgba(255, 255, 255, 0.6);
        user-select: none;
        pointer-events: none;
      }
      #stats-minimize-btn {
        position: absolute;
        top: 6px;
        right: 6px;
        background: rgba(0, 0, 0, 0.55);
        border: 1px solid rgba(255, 255, 255, 0.35);
        color: #fff;
        border-radius: 8px;
        width: 28px;
        height: 28px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        font-size: 1rem;
        font-weight: 700;
        line-height: 1;
        z-index: 2; /* ensure above panel content */
      }
      #stats-minimize-btn:hover {
        background: rgba(0, 0, 0, 0.5);
      }
      /* Floating restore button shown only when minimized */
      .stats-toggle-floating.hidden {
        display: none !important;
      }
      /* Overlay used during dragging to prevent selecting/clicking other content */
      #drag-overlay {
        position: fixed;
        inset: 0;
        background: transparent;
        z-index: 998;
        display: none;
        cursor: grabbing;
      }
    </style>
  </head>
  <body>
    <!-- Particles container -->
    <div class="particles-container" id="particles"></div>

    <!-- Update History Sidebar -->
    <div class="update-history-sidebar" id="update-sidebar">
      <div class="sidebar-header">
        <h3>üìã Update History</h3>
        <button class="sidebar-toggle" id="sidebar-toggle">‚Üê</button>
      </div>
      <div class="sidebar-content">
        <!-- Updates will be loaded dynamically -->
        <div id="updates-container">
          <div class="stat-item">
            <span class="stat-icon">üîÑ</span>
            <span class="stat-label">Loading updates...</span>
          </div>
        </div>
      </div>
    </div>

    <!-- Floating Controls Container -->
    <div class="floating-controls">
      <!-- Updates -->
      <button
        class="sidebar-toggle-floating"
        id="floating-toggle"
        aria-label="Updates"
      >
        <span class="fa-icon" aria-hidden="true">üìã</span>
        <span class="fa-label">Updates</span>
      </button>
      <!-- Admin Manager -->
      <a
        class="sidebar-toggle-floating admin-toggle-floating"
        href="{{ url_for('notification_admin') }}"
        aria-label="Enter Admin Manager"
      >
        <span class="fa-icon" aria-hidden="true">üõ°Ô∏è</span>
        <span class="fa-label">Admin Panel</span>
      </a>
      <!-- Discord -->
      <a
        class="sidebar-toggle-floating discord-toggle-floating"
        href="https://discord.com/invite/2S2WZMznVJ"
        target="_blank"
        rel="noopener"
        aria-label="Join I.B.U Discord"
      >
        <span class="fa-icon" aria-hidden="true"
          ><img
            src="{{ url_for('static', filename='discord-icon.svg') }}"
            alt=""
        /></span>
        <span class="fa-label">Join us on Discord!</span>
      </a>
      <!-- Stats restore (visible when minimized) -->
      <button
        class="sidebar-toggle-floating stats-toggle-floating hidden"
        id="stats-toggle-floating"
        aria-label="Show Daily Statistics"
      >
        <span class="fa-icon" aria-hidden="true">üìä</span>
        <span class="fa-label">Stats overview</span>
      </button>
    </div>

    <!-- Main landing container -->
    <div class="landing-container" id="main-container">
      <!-- Logo section -->
      <div class="logo-container">
        <img
          id="logo_IBU"
          src="{{ url_for('static', filename='ibu-icon.svg') }}"
          alt="IBU Logo"
          width="400"
          height="400"
          decoding="async"
          loading="eager"
        />
      </div>

      <!-- Content area -->
      <div class="content-area">
        <img
          id="IBU_text"
          src="{{ url_for('static', filename='ibu-text.svg') }}"
          alt="IBU Text"
          width="600"
          height="150"
          decoding="async"
          loading="eager"
        />
        <!-- Main action button -->
        <div
          style="display: inline-flex; flex-wrap: wrap; justify-content: center"
        >
          <a
            href="{{ url_for('visualization') }}"
            class="hero-button"
            style="margin-left: 1rem; margin-right: 1rem; margin-bottom: 1rem"
          >
            Team Data Analysis
          </a>

          <!-- Trends Analysis button -->
          <a
            href="{{ url_for('trends') }}"
            class="hero-button"
            style="
              background: linear-gradient(135deg, #66afea 0%, #4b5ba2 100%);
              margin-left: 1rem;
              margin-right: 1rem;
              margin-bottom: 1rem;
            "
          >
            Trends Analysis
          </a>

          <!-- Member Info button -->
          <a
            href="{{ url_for('member_info') }}"
            class="hero-button"
            style="
              background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
              margin-left: 1rem;
              margin-right: 1rem;
              margin-bottom: 1rem;
            "
          >
            Member Tracking
          </a>
        </div>
        <!-- Information section -->
        <div class="info-container">
          <p class="update-info" id="latest_date">
            New data received {{ time_ago }}
          </p>
          <p class="app-info">Data from {{ latest_date }}</p>

          <p class="creator-credit">
            by Mindeformer with the assistance of Kool Kid6958, Copilot and the
            support of our kind I.B.U members
          </p>
        </div>
      </div>
    </div>

    <!-- Typewriter text panel (hidden initially) -->
    <div class="text-panel" id="text-panel">
      <div class="text-content">
        <h2>Welcome to I.B.U Dashboard</h2>
        <div class="typewriter-text" id="typewriter-text"></div>
        <button class="back-button" id="back-button">‚Üê Back</button>
      </div>
    </div>

    <!-- Move stats panel OUTSIDE the landing-container for proper positioning -->
    <div class="stats-panel loaded" id="stats-panel">
      <div class="live-stats" id="live-stats">
        <h3>Statistics Overview</h3>
        <div class="stat-item">
          <span class="stat-icon">ÔøΩ</span>
          <span class="stat-label">Loading stats...</span>
        </div>
      </div>
    </div>
    <div id="drag-overlay"></div>

    <script>
      // Sidebar functionality
      function initSidebar() {
        const sidebar = document.getElementById("update-sidebar");
        const sidebarToggle = document.getElementById("sidebar-toggle");
        const floatingToggle = document.getElementById("floating-toggle");

        let isOpen = false;

        function openSidebar() {
          if (isOpen) return;
          isOpen = true;
          sidebar.classList.add("open");
          floatingToggle.classList.add("hidden");
          sidebarToggle.textContent = "‚Üê";
        }

        function closeSidebar() {
          if (!isOpen) return;
          isOpen = false;
          sidebar.classList.remove("open");
          floatingToggle.classList.remove("hidden");
          sidebarToggle.textContent = "‚Üí";
        }

        function toggleSidebar() {
          isOpen ? closeSidebar() : openSidebar();
        }

        sidebarToggle.addEventListener("click", toggleSidebar);
        floatingToggle.addEventListener("click", function (e) {
          e.preventDefault();
          e.stopPropagation();
          openSidebar();
        });
        // Also open when clicking anywhere inside the expanded Updates button
        const floatingControls = document.querySelector(".floating-controls");
        if (floatingControls) {
          floatingControls.addEventListener("click", (ev) => {
            const target = ev.target;
            if (
              target &&
              (target.id === "floating-toggle" ||
                (target.closest && target.closest("#floating-toggle")))
            ) {
              ev.preventDefault();
              ev.stopPropagation();
              openSidebar();
            }
          });
        }

        // Close sidebar when clicking outside (optional)
        document.addEventListener("click", function (e) {
          if (
            isOpen &&
            !sidebar.contains(e.target) &&
            !(floatingToggle && floatingToggle.contains(e.target))
          ) {
            closeSidebar();
          }
        });
      }

      // Load updates from server
      async function loadUpdates() {
        console.log("üîÑ Loading updates...");
        const updatesContainer = document.getElementById("updates-container");

        try {
          const response = await fetch("/get_updates");
          const data = await response.json();

          if (data.success && data.updates && data.updates.length > 0) {
            console.log("‚úÖ Updates loaded:", data.updates);

            let updatesHTML = "";

            data.updates.forEach((update) => {
              const currentClass = update.is_current ? " current" : "";

              updatesHTML += `
              <div class="update-item${currentClass}">
                <div class="update-header">
                  <span class="version">${update.version}</span>
                  <span class="date">${update.date}</span>
                </div>
                <div class="update-title">${update.title}</div>
                <div class="update-changes">
                  ${update.features
                    .map(
                      (feature) => `<div class="change-item">${feature}</div>`
                    )
                    .join("")}
                </div>
              </div>
            `;
            });

            updatesContainer.innerHTML = updatesHTML;
          } else {
            console.log("‚ö†Ô∏è No updates found or error:", data.error);
            updatesContainer.innerHTML = `
            <div class="update-item">
              <div class="update-header">
                <span class="version">No Updates</span>
                <span class="date">-</span>
              </div>
              <div class="update-title">No update history found</div>
              <div class="update-changes">
                <div class="change-item">üìù Edit static/updates.txt to add your first update</div>
              </div>
            </div>
          `;
          }
        } catch (error) {
          console.error("‚ùå Error loading updates:", error);
          updatesContainer.innerHTML = `
          <div class="update-item">
            <div class="update-header">
              <span class="version">Error</span>
              <span class="date">-</span>
            </div>
            <div class="update-title">Failed to load updates</div>
            <div class="update-changes">
              <div class="change-item">‚ùå ${error.message}</div>
              <div class="change-item">
                <button onclick="loadUpdates()" style="background: rgba(224, 97, 80, 0.8); border: none; color: white; padding: 8px 16px; border-radius: 8px; cursor: pointer; font-size: 0.85rem; margin-top: 8px;">
                  üîÑ Retry Loading
                </button>
              </div>
            </div>
          </div>
        `;
        }
      }

      // Particle system
      function createParticles() {
        const container = document.getElementById("particles");
        const particleCount = 15;

        for (let i = 0; i < particleCount; i++) {
          const particle = document.createElement("div");
          particle.className = "particle";

          // Random size between 2-6px
          const size = Math.random() * 4 + 2;
          particle.style.width = size + "px";
          particle.style.height = size + "px";

          // Random position
          particle.style.left = Math.random() * 100 + "%";
          particle.style.top = Math.random() * 100 + "%";

          // Random animation delay
          particle.style.animationDelay = Math.random() * 6 + "s";
          particle.style.animationDuration = Math.random() * 3 + 4 + "s";

          container.appendChild(particle);
        }
      }

      // Initialize particles when page loads
      document.addEventListener("DOMContentLoaded", function () {
        // Initialize sidebar functionality
        initSidebar();

        // Load updates from server
        loadUpdates();

        // Make update text clickable to open sidebar
        const updateText = document.querySelector(".minecraft-update-text");
        if (updateText) {
          updateText.addEventListener("click", function () {
            const sidebar = document.getElementById("update-sidebar");
            const floatingToggle = document.getElementById("floating-toggle");

            // Open the sidebar
            sidebar.classList.add("open");
            floatingToggle.classList.add("hidden");

            // Update the toggle button text
            const sidebarToggle = document.getElementById("sidebar-toggle");
            if (sidebarToggle) {
              sidebarToggle.textContent = "‚Üê";
            }
          });
        }

        createParticles();
        // Lock landing container layout after initial paint to avoid re-centering jitter
        requestAnimationFrame(() => {
          const lc = document.querySelector(".landing-container");
          if (lc) lc.classList.add("stabilized");
        });

        // Debug: Force stats panel visibility
        const statsPanel = document.getElementById("stats-panel");
        const liveStats = document.getElementById("live-stats");

        console.log("üîç Stats panel element:", statsPanel);
        console.log("üîç Live stats element:", liveStats);

        // Initialize draggable/minimizable stats panel
        //initStatsPanelWidget();

        if (liveStats) {
          liveStats.style.display = "flex";
          liveStats.style.visibility = "visible";
          liveStats.style.opacity = "1";
          liveStats.style.background = "rgba(42, 42, 42, 0.95)";
          console.log("‚úÖ Forced live stats visibility");
        } else {
          console.error("‚ùå Live stats element not found!");
        }

        // Interactive logo effects
        const logo = document.getElementById("logo_IBU");
        const mainContainer = document.getElementById("main-container");
        const textPanel = document.getElementById("text-panel");
        const backButton = document.getElementById("back-button");
        const typewriterText = document.getElementById("typewriter-text");

        let isExpanded = false;

        // Logo hover effects (class-based to ensure consistent reset)
        logo.addEventListener("mouseenter", function () {
          this.classList.add("logo-hover");
        });
        logo.addEventListener("mouseleave", function () {
          this.classList.remove("logo-hover");
        });

        // Logo click functionality with toggle
        logo.addEventListener("click", function () {
          const mainContainer = document.getElementById("main-container");
          const textPanel = document.getElementById("text-panel");
          const titleElement = document.querySelector(".text-content h2");
          const textElement = document.getElementById("typewriter-text");
          const buttonElement = document.getElementById("back-button"); // Add button reference

          if (!isExpanded) {
            isExpanded = true;

            // Mobile vs Desktop logic
            if (window.innerWidth <= 768) {
              textPanel.classList.add("active");
            } else {
              mainContainer.style.transform = "translateX(-25%)";
              textPanel.style.transform = "translateX(0)";
              textPanel.style.opacity = "1";
            }

            // Add text content and trigger fade-in
            setTimeout(() => {
              // Set the body text content (your specific text)
              textElement.innerHTML = `We are Intelligent Beings United!<br><br>
        Welcome to our dashboard, your comprehensive tool for analyzing team performance and statistics.

This dashboard provides daily insights into team data, allowing you to:<br><br>

‚Ä¢ Track team members points<br>
‚Ä¢ Analyze performance metrics over time<br>
‚Ä¢ See individual team member contributions<br>
‚Ä¢ Export data for further analysis<br><br>

The system automatically scrapes and updates team information, ensuring you always have the latest data at your fingertips.<br><br>

For more information, join our <a href="https://discord.com/invite/2S2WZMznVJ" target="_blank" style="color: rgba(224, 97, 80, 1); text-decoration: none;">I.B.U. Discord Server</a> !`;

              // Trigger title fade-in (first)
              setTimeout(() => {
                titleElement.classList.add("fade-in");
              }, 200);

              // Trigger text fade-in (second)
              setTimeout(() => {
                textElement.classList.add("fade-in");
              }, 500);

              // Trigger button fade-in (last)
              setTimeout(() => {
                buttonElement.classList.add("fade-in");
              }, 800);
            }, 600);
          } else {
            // Close panel
            isExpanded = false;

            // Remove fade-in classes from all elements
            titleElement.classList.remove("fade-in");
            textElement.classList.remove("fade-in");
            buttonElement.classList.remove("fade-in"); // Add button cleanup

            if (window.innerWidth <= 768) {
              textPanel.classList.remove("active");
            } else {
              mainContainer.style.transform = "translateX(0)";
              textPanel.style.transform = "translateX(100%)";
              textPanel.style.opacity = "0";
            }

            // Clear text content after animation
            setTimeout(() => {
              textElement.innerHTML = "";
            }, 600);
          }
        });

        // Back button functionality
        backButton.addEventListener("click", function () {
          const titleElement = document.querySelector(".text-content h2");
          const textElement = document.getElementById("typewriter-text");
          const buttonElement = document.getElementById("back-button");

          isExpanded = false;

          // Remove fade-in classes
          titleElement.classList.remove("fade-in");
          textElement.classList.remove("fade-in");
          buttonElement.classList.remove("fade-in");

          if (window.innerWidth <= 768) {
            textPanel.classList.remove("active");
          } else {
            mainContainer.style.transform = "translateX(0)";
            textPanel.style.transform = "translateX(100%)";
            textPanel.style.opacity = "0";
          }

          // Clear text content after animation
          setTimeout(() => {
            textElement.innerHTML = "";
          }, 600);
        });

        // Close panel function
        function closePanel() {
          isExpanded = false;
          if (window.innerWidth <= 768) {
            // Mobile: Hide full screen panel
            textPanel.classList.remove("active");
          } else {
            // Desktop: Slide back
            mainContainer.style.transform = "translateX(0)";
            textPanel.style.transform = "translateX(100%)";
          }
          textPanel.style.opacity = "0";

          // Reset text content
          typewriterText.innerHTML = "";
          typewriterText.classList.remove("fade-in");
        }

        // Smooth reveal effect (replaces typewriter)
        function startSmoothReveal() {
          const text = `We are Intelligent Beings United!
        Welcome to our dashboard, your comprehensive tool for analyzing team performance and statistics.

This dashboard provides daily insights into team data, allowing you to:

‚Ä¢ Track team members points
‚Ä¢ Analyze performance metrics over time
‚Ä¢ See individual team member contributions
‚Ä¢ Export data for further analysis

The system automatically scrapes and updates team information, ensuring you always have the latest data at your fingertips.

For more information, join our <a href="https://discord.com/invite/2S2WZMznVJ" target="_blank" style="color: rgba(224, 97, 80, 1); text-decoration: none;">I.B.U. Discord Server</a> !`;

          // Set text content immediately
          typewriterText.innerHTML = text.replace(/\n/g, "<br>");

          // Add fade-in class for smooth appearance
          setTimeout(() => {
            typewriterText.classList.add("fade-in");
          }, 200);
        }

        // Update the smoothReveal function in the HTML file
        function smoothReveal() {
          const titleElement = document.querySelector(".text-content h2");
          const textElement = document.getElementById("typewriter-text");

          // Set the text content
          textElement.innerHTML =
            "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.";

          // Trigger fade-in animations
          setTimeout(() => {
            titleElement.classList.add("fade-in");
          }, 200);

          setTimeout(() => {
            textElement.classList.add("fade-in");
          }, 500);
        }

        // Handle window resize
        window.addEventListener("resize", function () {
          if (textPanel.style.opacity === "1") {
            textPanel.classList.remove("active");
            mainContainer.style.transform = "translateX(0)";
            textPanel.style.transform = "translateX(100%)";
            textPanel.style.opacity = "0";
            typewriterText.innerHTML = "";
            typewriterText.classList.remove("fade-in");
          }
        });
      });

      // Add this script to index_IBU.html to load live stats

      async function loadLiveStats() {
        console.log("üîÑ Loading live stats...");
        const statsContainer = document.getElementById("live-stats");

        // Show loading state
        statsContainer.innerHTML = `
        <h3>Statistics Overview</h3>
        <div class="stat-item">
          <span class="stat-icon">üîÑ</span>
          <span class="stat-label">Loading data...</span>
        </div>
      `;

        try {
          // Try the simple stats endpoint first
          console.log("üì° Fetching from /get_simple_stats...");
          const response = await fetch("/get_simple_stats");
          console.log("üì° Stats response status:", response.status);

          if (response.ok) {
            const data = await response.json();
            console.log("üì¶ Stats data received:", data);

            if (data.success && data.stats) {
              const stats = data.stats;
              console.log("‚úÖ Processing stats:", stats);

              statsContainer.innerHTML = `
              <h3>Statistics Overview</h3>
              <div class="stat-item">
                <span class="stat-icon">üèÜ</span>
                <span class="stat-label">Total Team Points:</span>
                <span class="stat-value">${stats.total_points.toLocaleString()}</span>
              </div>
              <div class="stat-item">
                <span class="stat-icon">üë•</span>
                <span class="stat-label">Members:</span>
                <span class="stat-value">${stats.active_members}</span>
              </div>
              <div class="stat-item">
                <span class="stat-icon">‚≠ê</span>
                <span class="stat-label">Top 10 Performers:</span>
              </div>
              <div class="top-performers">
                ${stats.top_performers
                  .map(
                    (performer, index) => `
                  <div class="performer-item">
                    <span class="performer-rank">${index + 1}.</span>
                    <span class="performer-name">${performer.name}</span>
                    <span class="performer-points">${performer.points.toLocaleString()}</span>
                  </div>
                `
                  )
                  .join("")}
              </div>
            `;

              console.log("‚úÖ Stats UI updated successfully");
              document.getElementById("stats-panel").classList.add("loaded");
              // Reapply saved position now that content height is finalized
              try {
                if (window.__reapplyStatsPanelPosition)
                  window.__reapplyStatsPanelPosition();
              } catch {}
              return; // Success, exit function
            } else {
              console.error("‚ùå Invalid stats data structure:", data);
              throw new Error(data.error || "Invalid stats data structure");
            }
          } else {
            const errorText = await response.text();
            console.error("‚ùå HTTP error response:", errorText);
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          }
        } catch (error) {
          console.error("‚ùå Stats loading failed:", error);

          // Show error state with retry
          statsContainer.innerHTML = `
          <h3>üìä Statistics</h3>
          <div class="stat-item">
            <span class="stat-icon">‚ö†Ô∏è</span>
            <span class="stat-label">Failed to load data</span>
          </div>
          <div class="stat-item" style="font-size: 0.8rem; color: #999;">
            <span class="stat-label">Error: ${error.message}</span>
          </div>
          <div class="stat-item">
            <button onclick="loadLiveStats()" style="background: rgba(224, 97, 80, 0.8); border: none; color: white; padding: 8px 16px; border-radius: 8px; cursor: pointer; font-size: 0.85rem;">
              üîÑ Retry Loading
            </button>
          </div>
        `;
          document.getElementById("stats-panel").classList.add("loaded");
          // Reapply saved position even on error layout
          try {
            if (window.__reapplyStatsPanelPosition)
              window.__reapplyStatsPanelPosition();
          } catch {}
        }
      }

      // File monitoring and update functions
      let lastKnownFile = "";
      let fileCheckInterval;

      function updateFileInfo() {
        fetch("/get_latest_file_info")
          .then((response) => response.json())
          .then((data) => {
            if (data.success) {
              const latestDateElement = document.getElementById("latest_date");
              const appInfoElement = document.querySelector(".app-info");

              // Update the "New data received" text
              if (latestDateElement) {
                latestDateElement.textContent = `New data received ${data.time_ago}`;
              }

              // Update the "Data from" text
              if (appInfoElement) {
                appInfoElement.textContent = `Data from ${data.latest_date}`;
              }

              // Check if this is a new file (different from last known)
              if (lastKnownFile && lastKnownFile !== data.latest_file) {
                console.log("üÜï New file detected:", data.latest_file);

                // Show a subtle notification or animation
                if (latestDateElement) {
                  latestDateElement.style.animation = "pulse 2s ease-in-out";
                  setTimeout(() => {
                    latestDateElement.style.animation = "";
                  }, 2000);
                }

                // Refresh stats when new file is detected
                loadLiveStats();
              }

              lastKnownFile = data.latest_file;
              console.log("üìÑ File info updated:", data);
            } else {
              console.log("‚ö†Ô∏è No file info available:", data.message);
            }
          })
          .catch((error) => {
            console.error("‚ùå Error updating file info:", error);
          });
      }

      function startFileMonitoring() {
        // Update immediately
        updateFileInfo();

        // Then check every 30 seconds for new files
        fileCheckInterval = setInterval(updateFileInfo, 30000);
        console.log("üîÑ File monitoring started - checking every 30 seconds");
      }

      function stopFileMonitoring() {
        if (fileCheckInterval) {
          clearInterval(fileCheckInterval);
          console.log("‚èπÔ∏è File monitoring stopped");
        }
      }

      // Add local file status check function with retry logic
      function checkLocalFiles(retryCount = 0) {
        // Function removed - no longer needed for local file operation
      }

      // Load stats and check files when page loads
      document.addEventListener("DOMContentLoaded", function () {
        // Load stats immediately
        setTimeout(() => {
          console.log("üîÑ Loading stats...");
          loadLiveStats();
        });

        // Start monitoring for file changes
        setTimeout(() => {
          console.log("üîÑ Starting file monitoring...");
          startFileMonitoring();
        }, 1500);
      });
    </script>
    <script>
      // Draggable + Minimize logic for stats panel
      function initStatsPanelWidget() {
        const panel = document.getElementById("stats-panel");
        const restoreBtn = document.getElementById("stats-toggle-floating");
        const minimizeBtn = document.getElementById("stats-minimize-btn");
        const overlay = document.getElementById("drag-overlay");
        if (!panel || !restoreBtn || !minimizeBtn) return;

        const LS_POS = "statsPanelPos";
        const LS_MIN = "statsPanelMinimized";

        // Helpers
        function applyPos(pos) {
          if (!pos) return;
          // Ensure visibility for accurate measurements
          panel.classList.add("visible");
          panel.style.right = "auto";
          const rect = panel.getBoundingClientRect();
          const panelH = rect.height;
          const maxLeft = Math.max(0, window.innerWidth - rect.width);
          let left = Math.max(0, Math.min(maxLeft, pos.left || 0));
          // Compute top using anchor if available
          let top;
          if (pos.anchorY === "bottom" && typeof pos.bottomGap === "number") {
            top = window.innerHeight - panelH - pos.bottomGap;
          } else {
            top = typeof pos.top === "number" ? pos.top : 0;
          }
          // Final clamp
          const maxTop = Math.max(0, window.innerHeight - panelH);
          top = Math.max(0, Math.min(maxTop, top));
          panel.style.left = left + "px";
          panel.style.top = top + "px";
        }
        function savePos() {
          const rect = panel.getBoundingClientRect();
          const bottomGap = Math.max(
            0,
            window.innerHeight - (rect.top + rect.height)
          );
          const anchorY = bottomGap <= 40 ? "bottom" : "top"; // treat near-bottom as bottom-anchored
          const pos = {
            left: Math.max(
              0,
              Math.min(window.innerWidth - rect.width, rect.left)
            ),
            top: Math.max(
              0,
              Math.min(window.innerHeight - rect.height, rect.top)
            ),
            bottomGap,
            anchorY,
          };
          try {
            localStorage.setItem(LS_POS, JSON.stringify(pos));
          } catch {}
        }
        function getSavedPos() {
          try {
            return JSON.parse(localStorage.getItem(LS_POS) || "null");
          } catch {
            return null;
          }
        }
        function minimize() {
          panel.classList.add("is-hidden");
          panel.classList.remove("visible");
          restoreBtn.classList.remove("hidden");
          try {
            localStorage.setItem(LS_MIN, "1");
          } catch {}
        }
        function restore() {
          panel.classList.remove("is-hidden");
          panel.classList.add("visible");
          restoreBtn.classList.add("hidden");
          try {
            localStorage.removeItem(LS_MIN);
          } catch {}
          // Reapply saved position on restore
          const saved = getSavedPos();
          if (saved) applyPos(saved);
        }

        // Initial state
        const minimized = localStorage.getItem(LS_MIN) === "1";
        if (minimized) {
          panel.classList.add("is-hidden");
          restoreBtn.classList.remove("hidden");
        } else {
          // Default position if none saved
          const saved = getSavedPos();
          if (saved) {
            applyPos(saved);
          } else {
            // Place near right side, 20% from top
            const width = 320; // same as CSS
            const margin = 32;
            const left = Math.max(margin, window.innerWidth - width - margin);
            const top = Math.round(
              (window.innerHeight - panel.getBoundingClientRect().height) / 2
            );
            panel.style.left = left + "px";
            panel.style.top = top + "px";
            panel.style.right = "auto";
            panel.classList.add("visible");
          }
        }

        // Drag support
        let dragging = false;
        let startX = 0,
          startY = 0,
          origLeft = 0,
          origTop = 0;
        let moved = false;
        let rafId = null;
        let nextLeft = null;
        let nextTop = null;

        function onDown(e) {
          // Only left mouse or touch
          if (e.button !== undefined && e.button !== 0) return;
          const rect = panel.getBoundingClientRect();
          dragging = true;
          moved = false;
          startX = e.touches ? e.touches[0].clientX : e.clientX;
          startY = e.touches ? e.touches[0].clientY : e.clientY;
          origLeft = rect.left;
          origTop = rect.top;
          // Ensure we use left/top (not right/transform)
          panel.style.right = "auto";
          panel.style.transform = "none";
          panel.classList.add("dragging");
          if (overlay) overlay.style.display = "block";
          // Prevent selecting other elements
          document.body.style.userSelect = "none";
          document.addEventListener("mousemove", onMove);
          document.addEventListener("mouseup", onUp);
          document.addEventListener("touchmove", onMove, { passive: false });
          document.addEventListener("touchend", onUp);
        }
        function onMove(e) {
          if (!dragging) return;
          const x = e.touches ? e.touches[0].clientX : e.clientX;
          const y = e.touches ? e.touches[0].clientY : e.clientY;
          const dx = x - startX;
          const dy = y - startY;
          if (!moved && (Math.abs(dx) > 3 || Math.abs(dy) > 3)) moved = true;
          e.preventDefault();
          let left = origLeft + dx;
          let top = origTop + dy;
          // Defer DOM writes to next animation frame for smoothness
          nextLeft = left;
          nextTop = top;
          if (!rafId) {
            rafId = requestAnimationFrame(() => {
              rafId = null;
              // Clamp within viewport using current size
              const rect = panel.getBoundingClientRect();
              const maxLeft = window.innerWidth - rect.width;
              const maxTop = window.innerHeight - rect.height;
              let cl = Math.max(0, Math.min(maxLeft, nextLeft));
              let ct = Math.max(0, Math.min(maxTop, nextTop));
              panel.style.left = cl + "px";
              panel.style.top = ct + "px";
            });
          }
        }
        function onUp() {
          if (!dragging) return;
          dragging = false;
          document.removeEventListener("mousemove", onMove);
          document.removeEventListener("mouseup", onUp);
          document.removeEventListener("touchmove", onMove);
          document.removeEventListener("touchend", onUp);
          panel.classList.remove("dragging");
          if (overlay) overlay.style.display = "none";
          document.body.style.userSelect = "";
          savePos();
        }

        // Start drag from anywhere inside panel
        //panel.addEventListener("mousedown", onDown);
        //panel.addEventListener("touchstart", onDown, { passive: true });

        // Prevent click-through if it was a drag
        panel.addEventListener(
          "click",
          function (ev) {
            if (moved) {
              ev.preventDefault();
              ev.stopPropagation();
            }
            moved = false;
          },
          true
        );

        // Minimize/restore
        minimizeBtn.addEventListener("click", function (e) {
          e.stopPropagation();
          minimize();
        });
        restoreBtn.addEventListener("click", function (e) {
          e.preventDefault();
          restore();
        });

        // Re-clamp on resize
        window.addEventListener("resize", function () {
          // Reapply from saved anchor so height/viewport changes don't drift position
          const saved = getSavedPos();
          if (saved) applyPos(saved);
          savePos();
        });

        // Expose a one-shot reapply to be called after content height changes
        window.__reapplyStatsPanelPosition = function () {
          const saved = getSavedPos();
          if (saved) applyPos(saved);
        };
      }
    </script>
  </body>
</html>
